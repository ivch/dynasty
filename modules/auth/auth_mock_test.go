// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package auth

import (
	"context"
	"github.com/ivch/dynasty/models"
	"sync"
)

var (
	lockuserServiceMockUserByID               sync.RWMutex
	lockuserServiceMockUserByPhoneAndPassword sync.RWMutex
)

// Ensure, that userServiceMock does implement userService.
// If this is not the case, regenerate this file with moq.
var _ userService = &userServiceMock{}

// userServiceMock is a mock implementation of userService.
//
//     func TestSomethingThatUsesuserService(t *testing.T) {
//
//         // make and configure a mocked userService
//         mockeduserService := &userServiceMock{
//             UserByIDFunc: func(ctx context.Context, id uint) (*models.User, error) {
// 	               panic("mock out the UserByID method")
//             },
//             UserByPhoneAndPasswordFunc: func(ctx context.Context, phone string, password string) (*models.User, error) {
// 	               panic("mock out the UserByPhoneAndPassword method")
//             },
//         }
//
//         // use mockeduserService in code that requires userService
//         // and then make assertions.
//
//     }
type userServiceMock struct {
	// UserByIDFunc mocks the UserByID method.
	UserByIDFunc func(ctx context.Context, id uint) (*models.User, error)

	// UserByPhoneAndPasswordFunc mocks the UserByPhoneAndPassword method.
	UserByPhoneAndPasswordFunc func(ctx context.Context, phone string, password string) (*models.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// UserByID holds details about calls to the UserByID method.
		UserByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uint
		}
		// UserByPhoneAndPassword holds details about calls to the UserByPhoneAndPassword method.
		UserByPhoneAndPassword []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Phone is the phone argument value.
			Phone string
			// Password is the password argument value.
			Password string
		}
	}
}

// UserByID calls UserByIDFunc.
func (mock *userServiceMock) UserByID(ctx context.Context, id uint) (*models.User, error) {
	if mock.UserByIDFunc == nil {
		panic("userServiceMock.UserByIDFunc: method is nil but userService.UserByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uint
	}{
		Ctx: ctx,
		ID:  id,
	}
	lockuserServiceMockUserByID.Lock()
	mock.calls.UserByID = append(mock.calls.UserByID, callInfo)
	lockuserServiceMockUserByID.Unlock()
	return mock.UserByIDFunc(ctx, id)
}

// UserByIDCalls gets all the calls that were made to UserByID.
// Check the length with:
//     len(mockeduserService.UserByIDCalls())
func (mock *userServiceMock) UserByIDCalls() []struct {
	Ctx context.Context
	ID  uint
} {
	var calls []struct {
		Ctx context.Context
		ID  uint
	}
	lockuserServiceMockUserByID.RLock()
	calls = mock.calls.UserByID
	lockuserServiceMockUserByID.RUnlock()
	return calls
}

// UserByPhoneAndPassword calls UserByPhoneAndPasswordFunc.
func (mock *userServiceMock) UserByPhoneAndPassword(ctx context.Context, phone string, password string) (*models.User, error) {
	if mock.UserByPhoneAndPasswordFunc == nil {
		panic("userServiceMock.UserByPhoneAndPasswordFunc: method is nil but userService.UserByPhoneAndPassword was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Phone    string
		Password string
	}{
		Ctx:      ctx,
		Phone:    phone,
		Password: password,
	}
	lockuserServiceMockUserByPhoneAndPassword.Lock()
	mock.calls.UserByPhoneAndPassword = append(mock.calls.UserByPhoneAndPassword, callInfo)
	lockuserServiceMockUserByPhoneAndPassword.Unlock()
	return mock.UserByPhoneAndPasswordFunc(ctx, phone, password)
}

// UserByPhoneAndPasswordCalls gets all the calls that were made to UserByPhoneAndPassword.
// Check the length with:
//     len(mockeduserService.UserByPhoneAndPasswordCalls())
func (mock *userServiceMock) UserByPhoneAndPasswordCalls() []struct {
	Ctx      context.Context
	Phone    string
	Password string
} {
	var calls []struct {
		Ctx      context.Context
		Phone    string
		Password string
	}
	lockuserServiceMockUserByPhoneAndPassword.RLock()
	calls = mock.calls.UserByPhoneAndPassword
	lockuserServiceMockUserByPhoneAndPassword.RUnlock()
	return calls
}

var (
	lockauthRepositoryMockCreateSession            sync.RWMutex
	lockauthRepositoryMockDeleteSessionByID        sync.RWMutex
	lockauthRepositoryMockFindSessionByAccessToken sync.RWMutex
)

// Ensure, that authRepositoryMock does implement authRepository.
// If this is not the case, regenerate this file with moq.
var _ authRepository = &authRepositoryMock{}

// authRepositoryMock is a mock implementation of authRepository.
//
//     func TestSomethingThatUsesauthRepository(t *testing.T) {
//
//         // make and configure a mocked authRepository
//         mockedauthRepository := &authRepositoryMock{
//             CreateSessionFunc: func(userID uint) (string, error) {
// 	               panic("mock out the CreateSession method")
//             },
//             DeleteSessionByIDFunc: func(id string) error {
// 	               panic("mock out the DeleteSessionByID method")
//             },
//             FindSessionByAccessTokenFunc: func(token string) (*models.Session, error) {
// 	               panic("mock out the FindSessionByAccessToken method")
//             },
//         }
//
//         // use mockedauthRepository in code that requires authRepository
//         // and then make assertions.
//
//     }
type authRepositoryMock struct {
	// CreateSessionFunc mocks the CreateSession method.
	CreateSessionFunc func(userID uint) (string, error)

	// DeleteSessionByIDFunc mocks the DeleteSessionByID method.
	DeleteSessionByIDFunc func(id string) error

	// FindSessionByAccessTokenFunc mocks the FindSessionByAccessToken method.
	FindSessionByAccessTokenFunc func(token string) (*models.Session, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateSession holds details about calls to the CreateSession method.
		CreateSession []struct {
			// UserID is the userID argument value.
			UserID uint
		}
		// DeleteSessionByID holds details about calls to the DeleteSessionByID method.
		DeleteSessionByID []struct {
			// ID is the id argument value.
			ID string
		}
		// FindSessionByAccessToken holds details about calls to the FindSessionByAccessToken method.
		FindSessionByAccessToken []struct {
			// Token is the token argument value.
			Token string
		}
	}
}

// CreateSession calls CreateSessionFunc.
func (mock *authRepositoryMock) CreateSession(userID uint) (string, error) {
	if mock.CreateSessionFunc == nil {
		panic("authRepositoryMock.CreateSessionFunc: method is nil but authRepository.CreateSession was just called")
	}
	callInfo := struct {
		UserID uint
	}{
		UserID: userID,
	}
	lockauthRepositoryMockCreateSession.Lock()
	mock.calls.CreateSession = append(mock.calls.CreateSession, callInfo)
	lockauthRepositoryMockCreateSession.Unlock()
	return mock.CreateSessionFunc(userID)
}

// CreateSessionCalls gets all the calls that were made to CreateSession.
// Check the length with:
//     len(mockedauthRepository.CreateSessionCalls())
func (mock *authRepositoryMock) CreateSessionCalls() []struct {
	UserID uint
} {
	var calls []struct {
		UserID uint
	}
	lockauthRepositoryMockCreateSession.RLock()
	calls = mock.calls.CreateSession
	lockauthRepositoryMockCreateSession.RUnlock()
	return calls
}

// DeleteSessionByID calls DeleteSessionByIDFunc.
func (mock *authRepositoryMock) DeleteSessionByID(id string) error {
	if mock.DeleteSessionByIDFunc == nil {
		panic("authRepositoryMock.DeleteSessionByIDFunc: method is nil but authRepository.DeleteSessionByID was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	lockauthRepositoryMockDeleteSessionByID.Lock()
	mock.calls.DeleteSessionByID = append(mock.calls.DeleteSessionByID, callInfo)
	lockauthRepositoryMockDeleteSessionByID.Unlock()
	return mock.DeleteSessionByIDFunc(id)
}

// DeleteSessionByIDCalls gets all the calls that were made to DeleteSessionByID.
// Check the length with:
//     len(mockedauthRepository.DeleteSessionByIDCalls())
func (mock *authRepositoryMock) DeleteSessionByIDCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockauthRepositoryMockDeleteSessionByID.RLock()
	calls = mock.calls.DeleteSessionByID
	lockauthRepositoryMockDeleteSessionByID.RUnlock()
	return calls
}

// FindSessionByAccessToken calls FindSessionByAccessTokenFunc.
func (mock *authRepositoryMock) FindSessionByAccessToken(token string) (*models.Session, error) {
	if mock.FindSessionByAccessTokenFunc == nil {
		panic("authRepositoryMock.FindSessionByAccessTokenFunc: method is nil but authRepository.FindSessionByAccessToken was just called")
	}
	callInfo := struct {
		Token string
	}{
		Token: token,
	}
	lockauthRepositoryMockFindSessionByAccessToken.Lock()
	mock.calls.FindSessionByAccessToken = append(mock.calls.FindSessionByAccessToken, callInfo)
	lockauthRepositoryMockFindSessionByAccessToken.Unlock()
	return mock.FindSessionByAccessTokenFunc(token)
}

// FindSessionByAccessTokenCalls gets all the calls that were made to FindSessionByAccessToken.
// Check the length with:
//     len(mockedauthRepository.FindSessionByAccessTokenCalls())
func (mock *authRepositoryMock) FindSessionByAccessTokenCalls() []struct {
	Token string
} {
	var calls []struct {
		Token string
	}
	lockauthRepositoryMockFindSessionByAccessToken.RLock()
	calls = mock.calls.FindSessionByAccessToken
	lockauthRepositoryMockFindSessionByAccessToken.RUnlock()
	return calls
}

var (
	lockServiceMockGwfa    sync.RWMutex
	lockServiceMockLogin   sync.RWMutex
	lockServiceMockRefresh sync.RWMutex
)

// Ensure, that ServiceMock does implement Service.
// If this is not the case, regenerate this file with moq.
var _ Service = &ServiceMock{}

// ServiceMock is a mock implementation of Service.
//
//     func TestSomethingThatUsesService(t *testing.T) {
//
//         // make and configure a mocked Service
//         mockedService := &ServiceMock{
//             GwfaFunc: func(token string) (uint, error) {
// 	               panic("mock out the Gwfa method")
//             },
//             LoginFunc: func(ctx context.Context, request *loginRequest) (*loginResponse, error) {
// 	               panic("mock out the Login method")
//             },
//             RefreshFunc: func(ctx context.Context, r *refreshTokenRequest) (*loginResponse, error) {
// 	               panic("mock out the Refresh method")
//             },
//         }
//
//         // use mockedService in code that requires Service
//         // and then make assertions.
//
//     }
type ServiceMock struct {
	// GwfaFunc mocks the Gwfa method.
	GwfaFunc func(token string) (uint, error)

	// LoginFunc mocks the Login method.
	LoginFunc func(ctx context.Context, request *loginRequest) (*loginResponse, error)

	// RefreshFunc mocks the Refresh method.
	RefreshFunc func(ctx context.Context, r *refreshTokenRequest) (*loginResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// Gwfa holds details about calls to the Gwfa method.
		Gwfa []struct {
			// Token is the token argument value.
			Token string
		}
		// Login holds details about calls to the Login method.
		Login []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Request is the request argument value.
			Request *loginRequest
		}
		// Refresh holds details about calls to the Refresh method.
		Refresh []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// R is the r argument value.
			R *refreshTokenRequest
		}
	}
}

// Gwfa calls GwfaFunc.
func (mock *ServiceMock) Gwfa(token string) (uint, error) {
	if mock.GwfaFunc == nil {
		panic("ServiceMock.GwfaFunc: method is nil but Service.Gwfa was just called")
	}
	callInfo := struct {
		Token string
	}{
		Token: token,
	}
	lockServiceMockGwfa.Lock()
	mock.calls.Gwfa = append(mock.calls.Gwfa, callInfo)
	lockServiceMockGwfa.Unlock()
	return mock.GwfaFunc(token)
}

// GwfaCalls gets all the calls that were made to Gwfa.
// Check the length with:
//     len(mockedService.GwfaCalls())
func (mock *ServiceMock) GwfaCalls() []struct {
	Token string
} {
	var calls []struct {
		Token string
	}
	lockServiceMockGwfa.RLock()
	calls = mock.calls.Gwfa
	lockServiceMockGwfa.RUnlock()
	return calls
}

// Login calls LoginFunc.
func (mock *ServiceMock) Login(ctx context.Context, request *loginRequest) (*loginResponse, error) {
	if mock.LoginFunc == nil {
		panic("ServiceMock.LoginFunc: method is nil but Service.Login was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Request *loginRequest
	}{
		Ctx:     ctx,
		Request: request,
	}
	lockServiceMockLogin.Lock()
	mock.calls.Login = append(mock.calls.Login, callInfo)
	lockServiceMockLogin.Unlock()
	return mock.LoginFunc(ctx, request)
}

// LoginCalls gets all the calls that were made to Login.
// Check the length with:
//     len(mockedService.LoginCalls())
func (mock *ServiceMock) LoginCalls() []struct {
	Ctx     context.Context
	Request *loginRequest
} {
	var calls []struct {
		Ctx     context.Context
		Request *loginRequest
	}
	lockServiceMockLogin.RLock()
	calls = mock.calls.Login
	lockServiceMockLogin.RUnlock()
	return calls
}

// Refresh calls RefreshFunc.
func (mock *ServiceMock) Refresh(ctx context.Context, r *refreshTokenRequest) (*loginResponse, error) {
	if mock.RefreshFunc == nil {
		panic("ServiceMock.RefreshFunc: method is nil but Service.Refresh was just called")
	}
	callInfo := struct {
		Ctx context.Context
		R   *refreshTokenRequest
	}{
		Ctx: ctx,
		R:   r,
	}
	lockServiceMockRefresh.Lock()
	mock.calls.Refresh = append(mock.calls.Refresh, callInfo)
	lockServiceMockRefresh.Unlock()
	return mock.RefreshFunc(ctx, r)
}

// RefreshCalls gets all the calls that were made to Refresh.
// Check the length with:
//     len(mockedService.RefreshCalls())
func (mock *ServiceMock) RefreshCalls() []struct {
	Ctx context.Context
	R   *refreshTokenRequest
} {
	var calls []struct {
		Ctx context.Context
		R   *refreshTokenRequest
	}
	lockServiceMockRefresh.RLock()
	calls = mock.calls.Refresh
	lockServiceMockRefresh.RUnlock()
	return calls
}
