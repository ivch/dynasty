// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package dictionaries

import (
	"context"
	"github.com/ivch/dynasty/models/dto"
	"github.com/ivch/dynasty/models/entities"
	"sync"
)

var (
	lockdictRepositoryMockBuildingsList     sync.RWMutex
	lockdictRepositoryMockEntriesByBuilding sync.RWMutex
)

// Ensure, that dictRepositoryMock does implement dictRepository.
// If this is not the case, regenerate this file with moq.
var _ dictRepository = &dictRepositoryMock{}

// dictRepositoryMock is a mock implementation of dictRepository.
//
//     func TestSomethingThatUsesdictRepository(t *testing.T) {
//
//         // make and configure a mocked dictRepository
//         mockeddictRepository := &dictRepositoryMock{
//             BuildingsListFunc: func() ([]*entities.Building, error) {
// 	               panic("mock out the BuildingsList method")
//             },
//             EntriesByBuildingFunc: func(id uint) ([]*entities.Entry, error) {
// 	               panic("mock out the EntriesByBuilding method")
//             },
//         }
//
//         // use mockeddictRepository in code that requires dictRepository
//         // and then make assertions.
//
//     }
type dictRepositoryMock struct {
	// BuildingsListFunc mocks the BuildingsList method.
	BuildingsListFunc func() ([]*entities.Building, error)

	// EntriesByBuildingFunc mocks the EntriesByBuilding method.
	EntriesByBuildingFunc func(id uint) ([]*entities.Entry, error)

	// calls tracks calls to the methods.
	calls struct {
		// BuildingsList holds details about calls to the BuildingsList method.
		BuildingsList []struct {
		}
		// EntriesByBuilding holds details about calls to the EntriesByBuilding method.
		EntriesByBuilding []struct {
			// ID is the id argument value.
			ID uint
		}
	}
}

// BuildingsList calls BuildingsListFunc.
func (mock *dictRepositoryMock) BuildingsList() ([]*entities.Building, error) {
	if mock.BuildingsListFunc == nil {
		panic("dictRepositoryMock.BuildingsListFunc: method is nil but dictRepository.BuildingsList was just called")
	}
	callInfo := struct {
	}{}
	lockdictRepositoryMockBuildingsList.Lock()
	mock.calls.BuildingsList = append(mock.calls.BuildingsList, callInfo)
	lockdictRepositoryMockBuildingsList.Unlock()
	return mock.BuildingsListFunc()
}

// BuildingsListCalls gets all the calls that were made to BuildingsList.
// Check the length with:
//     len(mockeddictRepository.BuildingsListCalls())
func (mock *dictRepositoryMock) BuildingsListCalls() []struct {
} {
	var calls []struct {
	}
	lockdictRepositoryMockBuildingsList.RLock()
	calls = mock.calls.BuildingsList
	lockdictRepositoryMockBuildingsList.RUnlock()
	return calls
}

// EntriesByBuilding calls EntriesByBuildingFunc.
func (mock *dictRepositoryMock) EntriesByBuilding(id uint) ([]*entities.Entry, error) {
	if mock.EntriesByBuildingFunc == nil {
		panic("dictRepositoryMock.EntriesByBuildingFunc: method is nil but dictRepository.EntriesByBuilding was just called")
	}
	callInfo := struct {
		ID uint
	}{
		ID: id,
	}
	lockdictRepositoryMockEntriesByBuilding.Lock()
	mock.calls.EntriesByBuilding = append(mock.calls.EntriesByBuilding, callInfo)
	lockdictRepositoryMockEntriesByBuilding.Unlock()
	return mock.EntriesByBuildingFunc(id)
}

// EntriesByBuildingCalls gets all the calls that were made to EntriesByBuilding.
// Check the length with:
//     len(mockeddictRepository.EntriesByBuildingCalls())
func (mock *dictRepositoryMock) EntriesByBuildingCalls() []struct {
	ID uint
} {
	var calls []struct {
		ID uint
	}
	lockdictRepositoryMockEntriesByBuilding.RLock()
	calls = mock.calls.EntriesByBuilding
	lockdictRepositoryMockEntriesByBuilding.RUnlock()
	return calls
}

var (
	lockServiceMockBuildingsList sync.RWMutex
	lockServiceMockEntriesList   sync.RWMutex
)

// Ensure, that ServiceMock does implement Service.
// If this is not the case, regenerate this file with moq.
var _ Service = &ServiceMock{}

// ServiceMock is a mock implementation of Service.
//
//     func TestSomethingThatUsesService(t *testing.T) {
//
//         // make and configure a mocked Service
//         mockedService := &ServiceMock{
//             BuildingsListFunc: func(ctx context.Context) (*dto.BuildingsDictionaryResposnse, error) {
// 	               panic("mock out the BuildingsList method")
//             },
//             EntriesListFunc: func(ctx context.Context, buildingID uint) (*dto.EntriesDictionaryResponse, error) {
// 	               panic("mock out the EntriesList method")
//             },
//         }
//
//         // use mockedService in code that requires Service
//         // and then make assertions.
//
//     }
type ServiceMock struct {
	// BuildingsListFunc mocks the BuildingsList method.
	BuildingsListFunc func(ctx context.Context) (*dto.BuildingsDictionaryResposnse, error)

	// EntriesListFunc mocks the EntriesList method.
	EntriesListFunc func(ctx context.Context, buildingID uint) (*dto.EntriesDictionaryResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// BuildingsList holds details about calls to the BuildingsList method.
		BuildingsList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// EntriesList holds details about calls to the EntriesList method.
		EntriesList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BuildingID is the buildingID argument value.
			BuildingID uint
		}
	}
}

// BuildingsList calls BuildingsListFunc.
func (mock *ServiceMock) BuildingsList(ctx context.Context) (*dto.BuildingsDictionaryResposnse, error) {
	if mock.BuildingsListFunc == nil {
		panic("ServiceMock.BuildingsListFunc: method is nil but Service.BuildingsList was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	lockServiceMockBuildingsList.Lock()
	mock.calls.BuildingsList = append(mock.calls.BuildingsList, callInfo)
	lockServiceMockBuildingsList.Unlock()
	return mock.BuildingsListFunc(ctx)
}

// BuildingsListCalls gets all the calls that were made to BuildingsList.
// Check the length with:
//     len(mockedService.BuildingsListCalls())
func (mock *ServiceMock) BuildingsListCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	lockServiceMockBuildingsList.RLock()
	calls = mock.calls.BuildingsList
	lockServiceMockBuildingsList.RUnlock()
	return calls
}

// EntriesList calls EntriesListFunc.
func (mock *ServiceMock) EntriesList(ctx context.Context, buildingID uint) (*dto.EntriesDictionaryResponse, error) {
	if mock.EntriesListFunc == nil {
		panic("ServiceMock.EntriesListFunc: method is nil but Service.EntriesList was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		BuildingID uint
	}{
		Ctx:        ctx,
		BuildingID: buildingID,
	}
	lockServiceMockEntriesList.Lock()
	mock.calls.EntriesList = append(mock.calls.EntriesList, callInfo)
	lockServiceMockEntriesList.Unlock()
	return mock.EntriesListFunc(ctx, buildingID)
}

// EntriesListCalls gets all the calls that were made to EntriesList.
// Check the length with:
//     len(mockedService.EntriesListCalls())
func (mock *ServiceMock) EntriesListCalls() []struct {
	Ctx        context.Context
	BuildingID uint
} {
	var calls []struct {
		Ctx        context.Context
		BuildingID uint
	}
	lockServiceMockEntriesList.RLock()
	calls = mock.calls.EntriesList
	lockServiceMockEntriesList.RUnlock()
	return calls
}
