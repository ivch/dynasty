// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package dictionaries

import (
	"sync"
)

// Ensure, that dictRepositoryMock does implement dictRepository.
// If this is not the case, regenerate this file with moq.
var _ dictRepository = &dictRepositoryMock{}

// dictRepositoryMock is a mock implementation of dictRepository.
//
//	func TestSomethingThatUsesdictRepository(t *testing.T) {
//
//		// make and configure a mocked dictRepository
//		mockeddictRepository := &dictRepositoryMock{
//			BuildingsListFunc: func() ([]*Building, error) {
//				panic("mock out the BuildingsList method")
//			},
//			EntriesByBuildingFunc: func(id uint) ([]*Entry, error) {
//				panic("mock out the EntriesByBuilding method")
//			},
//		}
//
//		// use mockeddictRepository in code that requires dictRepository
//		// and then make assertions.
//
//	}
type dictRepositoryMock struct {
	// BuildingsListFunc mocks the BuildingsList method.
	BuildingsListFunc func() ([]*Building, error)

	// EntriesByBuildingFunc mocks the EntriesByBuilding method.
	EntriesByBuildingFunc func(id uint) ([]*Entry, error)

	// calls tracks calls to the methods.
	calls struct {
		// BuildingsList holds details about calls to the BuildingsList method.
		BuildingsList []struct {
		}
		// EntriesByBuilding holds details about calls to the EntriesByBuilding method.
		EntriesByBuilding []struct {
			// ID is the id argument value.
			ID uint
		}
	}
	lockBuildingsList     sync.RWMutex
	lockEntriesByBuilding sync.RWMutex
}

// BuildingsList calls BuildingsListFunc.
func (mock *dictRepositoryMock) BuildingsList() ([]*Building, error) {
	if mock.BuildingsListFunc == nil {
		panic("dictRepositoryMock.BuildingsListFunc: method is nil but dictRepository.BuildingsList was just called")
	}
	callInfo := struct {
	}{}
	mock.lockBuildingsList.Lock()
	mock.calls.BuildingsList = append(mock.calls.BuildingsList, callInfo)
	mock.lockBuildingsList.Unlock()
	return mock.BuildingsListFunc()
}

// BuildingsListCalls gets all the calls that were made to BuildingsList.
// Check the length with:
//
//	len(mockeddictRepository.BuildingsListCalls())
func (mock *dictRepositoryMock) BuildingsListCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockBuildingsList.RLock()
	calls = mock.calls.BuildingsList
	mock.lockBuildingsList.RUnlock()
	return calls
}

// EntriesByBuilding calls EntriesByBuildingFunc.
func (mock *dictRepositoryMock) EntriesByBuilding(id uint) ([]*Entry, error) {
	if mock.EntriesByBuildingFunc == nil {
		panic("dictRepositoryMock.EntriesByBuildingFunc: method is nil but dictRepository.EntriesByBuilding was just called")
	}
	callInfo := struct {
		ID uint
	}{
		ID: id,
	}
	mock.lockEntriesByBuilding.Lock()
	mock.calls.EntriesByBuilding = append(mock.calls.EntriesByBuilding, callInfo)
	mock.lockEntriesByBuilding.Unlock()
	return mock.EntriesByBuildingFunc(id)
}

// EntriesByBuildingCalls gets all the calls that were made to EntriesByBuilding.
// Check the length with:
//
//	len(mockeddictRepository.EntriesByBuildingCalls())
func (mock *dictRepositoryMock) EntriesByBuildingCalls() []struct {
	ID uint
} {
	var calls []struct {
		ID uint
	}
	mock.lockEntriesByBuilding.RLock()
	calls = mock.calls.EntriesByBuilding
	mock.lockEntriesByBuilding.RUnlock()
	return calls
}
