// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package auth

import (
	"context"
	users "github.com/ivch/dynasty/server/handlers/users/transport"
	"sync"
)

// Ensure, that userServiceMock does implement userService.
// If this is not the case, regenerate this file with moq.
var _ userService = &userServiceMock{}

// userServiceMock is a mock implementation of userService.
//
//	func TestSomethingThatUsesuserService(t *testing.T) {
//
//		// make and configure a mocked userService
//		mockeduserService := &userServiceMock{
//			UserByIDFunc: func(ctx context.Context, id uint) (*users.UserByIDResponse, error) {
//				panic("mock out the UserByID method")
//			},
//			UserByPhoneAndPasswordFunc: func(ctx context.Context, phone string, password string) (*users.UserByIDResponse, error) {
//				panic("mock out the UserByPhoneAndPassword method")
//			},
//		}
//
//		// use mockeduserService in code that requires userService
//		// and then make assertions.
//
//	}
type userServiceMock struct {
	// UserByIDFunc mocks the UserByID method.
	UserByIDFunc func(ctx context.Context, id uint) (*users.UserByIDResponse, error)

	// UserByPhoneAndPasswordFunc mocks the UserByPhoneAndPassword method.
	UserByPhoneAndPasswordFunc func(ctx context.Context, phone string, password string) (*users.UserByIDResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// UserByID holds details about calls to the UserByID method.
		UserByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uint
		}
		// UserByPhoneAndPassword holds details about calls to the UserByPhoneAndPassword method.
		UserByPhoneAndPassword []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Phone is the phone argument value.
			Phone string
			// Password is the password argument value.
			Password string
		}
	}
	lockUserByID               sync.RWMutex
	lockUserByPhoneAndPassword sync.RWMutex
}

// UserByID calls UserByIDFunc.
func (mock *userServiceMock) UserByID(ctx context.Context, id uint) (*users.UserByIDResponse, error) {
	if mock.UserByIDFunc == nil {
		panic("userServiceMock.UserByIDFunc: method is nil but userService.UserByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uint
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockUserByID.Lock()
	mock.calls.UserByID = append(mock.calls.UserByID, callInfo)
	mock.lockUserByID.Unlock()
	return mock.UserByIDFunc(ctx, id)
}

// UserByIDCalls gets all the calls that were made to UserByID.
// Check the length with:
//
//	len(mockeduserService.UserByIDCalls())
func (mock *userServiceMock) UserByIDCalls() []struct {
	Ctx context.Context
	ID  uint
} {
	var calls []struct {
		Ctx context.Context
		ID  uint
	}
	mock.lockUserByID.RLock()
	calls = mock.calls.UserByID
	mock.lockUserByID.RUnlock()
	return calls
}

// UserByPhoneAndPassword calls UserByPhoneAndPasswordFunc.
func (mock *userServiceMock) UserByPhoneAndPassword(ctx context.Context, phone string, password string) (*users.UserByIDResponse, error) {
	if mock.UserByPhoneAndPasswordFunc == nil {
		panic("userServiceMock.UserByPhoneAndPasswordFunc: method is nil but userService.UserByPhoneAndPassword was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Phone    string
		Password string
	}{
		Ctx:      ctx,
		Phone:    phone,
		Password: password,
	}
	mock.lockUserByPhoneAndPassword.Lock()
	mock.calls.UserByPhoneAndPassword = append(mock.calls.UserByPhoneAndPassword, callInfo)
	mock.lockUserByPhoneAndPassword.Unlock()
	return mock.UserByPhoneAndPasswordFunc(ctx, phone, password)
}

// UserByPhoneAndPasswordCalls gets all the calls that were made to UserByPhoneAndPassword.
// Check the length with:
//
//	len(mockeduserService.UserByPhoneAndPasswordCalls())
func (mock *userServiceMock) UserByPhoneAndPasswordCalls() []struct {
	Ctx      context.Context
	Phone    string
	Password string
} {
	var calls []struct {
		Ctx      context.Context
		Phone    string
		Password string
	}
	mock.lockUserByPhoneAndPassword.RLock()
	calls = mock.calls.UserByPhoneAndPassword
	mock.lockUserByPhoneAndPassword.RUnlock()
	return calls
}

// Ensure, that authRepositoryMock does implement authRepository.
// If this is not the case, regenerate this file with moq.
var _ authRepository = &authRepositoryMock{}

// authRepositoryMock is a mock implementation of authRepository.
//
//	func TestSomethingThatUsesauthRepository(t *testing.T) {
//
//		// make and configure a mocked authRepository
//		mockedauthRepository := &authRepositoryMock{
//			CreateSessionFunc: func(userID uint) (string, error) {
//				panic("mock out the CreateSession method")
//			},
//			DeleteSessionByIDFunc: func(id string) error {
//				panic("mock out the DeleteSessionByID method")
//			},
//			DeleteSessionByUserIDFunc: func(id uint) error {
//				panic("mock out the DeleteSessionByUserID method")
//			},
//			FindSessionByAccessTokenFunc: func(token string) (*Session, error) {
//				panic("mock out the FindSessionByAccessToken method")
//			},
//			FindSessionByUserIDFunc: func(id uint) (*Session, error) {
//				panic("mock out the FindSessionByUserID method")
//			},
//		}
//
//		// use mockedauthRepository in code that requires authRepository
//		// and then make assertions.
//
//	}
type authRepositoryMock struct {
	// CreateSessionFunc mocks the CreateSession method.
	CreateSessionFunc func(userID uint) (string, error)

	// DeleteSessionByIDFunc mocks the DeleteSessionByID method.
	DeleteSessionByIDFunc func(id string) error

	// DeleteSessionByUserIDFunc mocks the DeleteSessionByUserID method.
	DeleteSessionByUserIDFunc func(id uint) error

	// FindSessionByAccessTokenFunc mocks the FindSessionByAccessToken method.
	FindSessionByAccessTokenFunc func(token string) (*Session, error)

	// FindSessionByUserIDFunc mocks the FindSessionByUserID method.
	FindSessionByUserIDFunc func(id uint) (*Session, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateSession holds details about calls to the CreateSession method.
		CreateSession []struct {
			// UserID is the userID argument value.
			UserID uint
		}
		// DeleteSessionByID holds details about calls to the DeleteSessionByID method.
		DeleteSessionByID []struct {
			// ID is the id argument value.
			ID string
		}
		// DeleteSessionByUserID holds details about calls to the DeleteSessionByUserID method.
		DeleteSessionByUserID []struct {
			// ID is the id argument value.
			ID uint
		}
		// FindSessionByAccessToken holds details about calls to the FindSessionByAccessToken method.
		FindSessionByAccessToken []struct {
			// Token is the token argument value.
			Token string
		}
		// FindSessionByUserID holds details about calls to the FindSessionByUserID method.
		FindSessionByUserID []struct {
			// ID is the id argument value.
			ID uint
		}
	}
	lockCreateSession            sync.RWMutex
	lockDeleteSessionByID        sync.RWMutex
	lockDeleteSessionByUserID    sync.RWMutex
	lockFindSessionByAccessToken sync.RWMutex
	lockFindSessionByUserID      sync.RWMutex
}

// CreateSession calls CreateSessionFunc.
func (mock *authRepositoryMock) CreateSession(userID uint) (string, error) {
	if mock.CreateSessionFunc == nil {
		panic("authRepositoryMock.CreateSessionFunc: method is nil but authRepository.CreateSession was just called")
	}
	callInfo := struct {
		UserID uint
	}{
		UserID: userID,
	}
	mock.lockCreateSession.Lock()
	mock.calls.CreateSession = append(mock.calls.CreateSession, callInfo)
	mock.lockCreateSession.Unlock()
	return mock.CreateSessionFunc(userID)
}

// CreateSessionCalls gets all the calls that were made to CreateSession.
// Check the length with:
//
//	len(mockedauthRepository.CreateSessionCalls())
func (mock *authRepositoryMock) CreateSessionCalls() []struct {
	UserID uint
} {
	var calls []struct {
		UserID uint
	}
	mock.lockCreateSession.RLock()
	calls = mock.calls.CreateSession
	mock.lockCreateSession.RUnlock()
	return calls
}

// DeleteSessionByID calls DeleteSessionByIDFunc.
func (mock *authRepositoryMock) DeleteSessionByID(id string) error {
	if mock.DeleteSessionByIDFunc == nil {
		panic("authRepositoryMock.DeleteSessionByIDFunc: method is nil but authRepository.DeleteSessionByID was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	mock.lockDeleteSessionByID.Lock()
	mock.calls.DeleteSessionByID = append(mock.calls.DeleteSessionByID, callInfo)
	mock.lockDeleteSessionByID.Unlock()
	return mock.DeleteSessionByIDFunc(id)
}

// DeleteSessionByIDCalls gets all the calls that were made to DeleteSessionByID.
// Check the length with:
//
//	len(mockedauthRepository.DeleteSessionByIDCalls())
func (mock *authRepositoryMock) DeleteSessionByIDCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	mock.lockDeleteSessionByID.RLock()
	calls = mock.calls.DeleteSessionByID
	mock.lockDeleteSessionByID.RUnlock()
	return calls
}

// DeleteSessionByUserID calls DeleteSessionByUserIDFunc.
func (mock *authRepositoryMock) DeleteSessionByUserID(id uint) error {
	if mock.DeleteSessionByUserIDFunc == nil {
		panic("authRepositoryMock.DeleteSessionByUserIDFunc: method is nil but authRepository.DeleteSessionByUserID was just called")
	}
	callInfo := struct {
		ID uint
	}{
		ID: id,
	}
	mock.lockDeleteSessionByUserID.Lock()
	mock.calls.DeleteSessionByUserID = append(mock.calls.DeleteSessionByUserID, callInfo)
	mock.lockDeleteSessionByUserID.Unlock()
	return mock.DeleteSessionByUserIDFunc(id)
}

// DeleteSessionByUserIDCalls gets all the calls that were made to DeleteSessionByUserID.
// Check the length with:
//
//	len(mockedauthRepository.DeleteSessionByUserIDCalls())
func (mock *authRepositoryMock) DeleteSessionByUserIDCalls() []struct {
	ID uint
} {
	var calls []struct {
		ID uint
	}
	mock.lockDeleteSessionByUserID.RLock()
	calls = mock.calls.DeleteSessionByUserID
	mock.lockDeleteSessionByUserID.RUnlock()
	return calls
}

// FindSessionByAccessToken calls FindSessionByAccessTokenFunc.
func (mock *authRepositoryMock) FindSessionByAccessToken(token string) (*Session, error) {
	if mock.FindSessionByAccessTokenFunc == nil {
		panic("authRepositoryMock.FindSessionByAccessTokenFunc: method is nil but authRepository.FindSessionByAccessToken was just called")
	}
	callInfo := struct {
		Token string
	}{
		Token: token,
	}
	mock.lockFindSessionByAccessToken.Lock()
	mock.calls.FindSessionByAccessToken = append(mock.calls.FindSessionByAccessToken, callInfo)
	mock.lockFindSessionByAccessToken.Unlock()
	return mock.FindSessionByAccessTokenFunc(token)
}

// FindSessionByAccessTokenCalls gets all the calls that were made to FindSessionByAccessToken.
// Check the length with:
//
//	len(mockedauthRepository.FindSessionByAccessTokenCalls())
func (mock *authRepositoryMock) FindSessionByAccessTokenCalls() []struct {
	Token string
} {
	var calls []struct {
		Token string
	}
	mock.lockFindSessionByAccessToken.RLock()
	calls = mock.calls.FindSessionByAccessToken
	mock.lockFindSessionByAccessToken.RUnlock()
	return calls
}

// FindSessionByUserID calls FindSessionByUserIDFunc.
func (mock *authRepositoryMock) FindSessionByUserID(id uint) (*Session, error) {
	if mock.FindSessionByUserIDFunc == nil {
		panic("authRepositoryMock.FindSessionByUserIDFunc: method is nil but authRepository.FindSessionByUserID was just called")
	}
	callInfo := struct {
		ID uint
	}{
		ID: id,
	}
	mock.lockFindSessionByUserID.Lock()
	mock.calls.FindSessionByUserID = append(mock.calls.FindSessionByUserID, callInfo)
	mock.lockFindSessionByUserID.Unlock()
	return mock.FindSessionByUserIDFunc(id)
}

// FindSessionByUserIDCalls gets all the calls that were made to FindSessionByUserID.
// Check the length with:
//
//	len(mockedauthRepository.FindSessionByUserIDCalls())
func (mock *authRepositoryMock) FindSessionByUserIDCalls() []struct {
	ID uint
} {
	var calls []struct {
		ID uint
	}
	mock.lockFindSessionByUserID.RLock()
	calls = mock.calls.FindSessionByUserID
	mock.lockFindSessionByUserID.RUnlock()
	return calls
}
