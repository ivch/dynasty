// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package auth

import (
	"context"
	"github.com/ivch/dynasty/server/handlers/users/transport"
	"sync"
)

var (
	lockuserServiceMockUserByID               sync.RWMutex
	lockuserServiceMockUserByPhoneAndPassword sync.RWMutex
)

// Ensure, that userServiceMock does implement userService.
// If this is not the case, regenerate this file with moq.
var _ userService = &userServiceMock{}

// userServiceMock is a mock implementation of userService.
//
//     func TestSomethingThatUsesuserService(t *testing.T) {
//
//         // make and configure a mocked userService
//         mockeduserService := &userServiceMock{
//             UserByIDFunc: func(ctx context.Context, id uint) (*transport.UserByIDResponse, error) {
// 	               panic("mock out the UserByID method")
//             },
//             UserByPhoneAndPasswordFunc: func(ctx context.Context, phone string, password string) (*transport.UserByIDResponse, error) {
// 	               panic("mock out the UserByPhoneAndPassword method")
//             },
//         }
//
//         // use mockeduserService in code that requires userService
//         // and then make assertions.
//
//     }
type userServiceMock struct {
	// UserByIDFunc mocks the UserByID method.
	UserByIDFunc func(ctx context.Context, id uint) (*transport.UserByIDResponse, error)

	// UserByPhoneAndPasswordFunc mocks the UserByPhoneAndPassword method.
	UserByPhoneAndPasswordFunc func(ctx context.Context, phone string, password string) (*transport.UserByIDResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// UserByID holds details about calls to the UserByID method.
		UserByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uint
		}
		// UserByPhoneAndPassword holds details about calls to the UserByPhoneAndPassword method.
		UserByPhoneAndPassword []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Phone is the phone argument value.
			Phone string
			// Password is the password argument value.
			Password string
		}
	}
}

// UserByID calls UserByIDFunc.
func (mock *userServiceMock) UserByID(ctx context.Context, id uint) (*transport.UserByIDResponse, error) {
	if mock.UserByIDFunc == nil {
		panic("userServiceMock.UserByIDFunc: method is nil but userService.UserByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uint
	}{
		Ctx: ctx,
		ID:  id,
	}
	lockuserServiceMockUserByID.Lock()
	mock.calls.UserByID = append(mock.calls.UserByID, callInfo)
	lockuserServiceMockUserByID.Unlock()
	return mock.UserByIDFunc(ctx, id)
}

// UserByIDCalls gets all the calls that were made to UserByID.
// Check the length with:
//     len(mockeduserService.UserByIDCalls())
func (mock *userServiceMock) UserByIDCalls() []struct {
	Ctx context.Context
	ID  uint
} {
	var calls []struct {
		Ctx context.Context
		ID  uint
	}
	lockuserServiceMockUserByID.RLock()
	calls = mock.calls.UserByID
	lockuserServiceMockUserByID.RUnlock()
	return calls
}

// UserByPhoneAndPassword calls UserByPhoneAndPasswordFunc.
func (mock *userServiceMock) UserByPhoneAndPassword(ctx context.Context, phone string, password string) (*transport.UserByIDResponse, error) {
	if mock.UserByPhoneAndPasswordFunc == nil {
		panic("userServiceMock.UserByPhoneAndPasswordFunc: method is nil but userService.UserByPhoneAndPassword was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Phone    string
		Password string
	}{
		Ctx:      ctx,
		Phone:    phone,
		Password: password,
	}
	lockuserServiceMockUserByPhoneAndPassword.Lock()
	mock.calls.UserByPhoneAndPassword = append(mock.calls.UserByPhoneAndPassword, callInfo)
	lockuserServiceMockUserByPhoneAndPassword.Unlock()
	return mock.UserByPhoneAndPasswordFunc(ctx, phone, password)
}

// UserByPhoneAndPasswordCalls gets all the calls that were made to UserByPhoneAndPassword.
// Check the length with:
//     len(mockeduserService.UserByPhoneAndPasswordCalls())
func (mock *userServiceMock) UserByPhoneAndPasswordCalls() []struct {
	Ctx      context.Context
	Phone    string
	Password string
} {
	var calls []struct {
		Ctx      context.Context
		Phone    string
		Password string
	}
	lockuserServiceMockUserByPhoneAndPassword.RLock()
	calls = mock.calls.UserByPhoneAndPassword
	lockuserServiceMockUserByPhoneAndPassword.RUnlock()
	return calls
}

var (
	lockauthRepositoryMockCreateSession            sync.RWMutex
	lockauthRepositoryMockDeleteSessionByID        sync.RWMutex
	lockauthRepositoryMockDeleteSessionByUserID    sync.RWMutex
	lockauthRepositoryMockFindSessionByAccessToken sync.RWMutex
)

// Ensure, that authRepositoryMock does implement authRepository.
// If this is not the case, regenerate this file with moq.
var _ authRepository = &authRepositoryMock{}

// authRepositoryMock is a mock implementation of authRepository.
//
//     func TestSomethingThatUsesauthRepository(t *testing.T) {
//
//         // make and configure a mocked authRepository
//         mockedauthRepository := &authRepositoryMock{
//             CreateSessionFunc: func(userID uint) (string, error) {
// 	               panic("mock out the CreateSession method")
//             },
//             DeleteSessionByIDFunc: func(id string) error {
// 	               panic("mock out the DeleteSessionByID method")
//             },
//             DeleteSessionByUserIDFunc: func(id uint) error {
// 	               panic("mock out the DeleteSessionByUserID method")
//             },
//             FindSessionByAccessTokenFunc: func(token string) (*Session, error) {
// 	               panic("mock out the FindSessionByAccessToken method")
//             },
//         }
//
//         // use mockedauthRepository in code that requires authRepository
//         // and then make assertions.
//
//     }
type authRepositoryMock struct {
	// CreateSessionFunc mocks the CreateSession method.
	CreateSessionFunc func(userID uint) (string, error)

	// DeleteSessionByIDFunc mocks the DeleteSessionByID method.
	DeleteSessionByIDFunc func(id string) error

	// DeleteSessionByUserIDFunc mocks the DeleteSessionByUserID method.
	DeleteSessionByUserIDFunc func(id uint) error

	// FindSessionByAccessTokenFunc mocks the FindSessionByAccessToken method.
	FindSessionByAccessTokenFunc func(token string) (*Session, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateSession holds details about calls to the CreateSession method.
		CreateSession []struct {
			// UserID is the userID argument value.
			UserID uint
		}
		// DeleteSessionByID holds details about calls to the DeleteSessionByID method.
		DeleteSessionByID []struct {
			// ID is the id argument value.
			ID string
		}
		// DeleteSessionByUserID holds details about calls to the DeleteSessionByUserID method.
		DeleteSessionByUserID []struct {
			// ID is the id argument value.
			ID uint
		}
		// FindSessionByAccessToken holds details about calls to the FindSessionByAccessToken method.
		FindSessionByAccessToken []struct {
			// Token is the token argument value.
			Token string
		}
	}
}

// CreateSession calls CreateSessionFunc.
func (mock *authRepositoryMock) CreateSession(userID uint) (string, error) {
	if mock.CreateSessionFunc == nil {
		panic("authRepositoryMock.CreateSessionFunc: method is nil but authRepository.CreateSession was just called")
	}
	callInfo := struct {
		UserID uint
	}{
		UserID: userID,
	}
	lockauthRepositoryMockCreateSession.Lock()
	mock.calls.CreateSession = append(mock.calls.CreateSession, callInfo)
	lockauthRepositoryMockCreateSession.Unlock()
	return mock.CreateSessionFunc(userID)
}

// CreateSessionCalls gets all the calls that were made to CreateSession.
// Check the length with:
//     len(mockedauthRepository.CreateSessionCalls())
func (mock *authRepositoryMock) CreateSessionCalls() []struct {
	UserID uint
} {
	var calls []struct {
		UserID uint
	}
	lockauthRepositoryMockCreateSession.RLock()
	calls = mock.calls.CreateSession
	lockauthRepositoryMockCreateSession.RUnlock()
	return calls
}

// DeleteSessionByID calls DeleteSessionByIDFunc.
func (mock *authRepositoryMock) DeleteSessionByID(id string) error {
	if mock.DeleteSessionByIDFunc == nil {
		panic("authRepositoryMock.DeleteSessionByIDFunc: method is nil but authRepository.DeleteSessionByID was just called")
	}
	callInfo := struct {
		ID string
	}{
		ID: id,
	}
	lockauthRepositoryMockDeleteSessionByID.Lock()
	mock.calls.DeleteSessionByID = append(mock.calls.DeleteSessionByID, callInfo)
	lockauthRepositoryMockDeleteSessionByID.Unlock()
	return mock.DeleteSessionByIDFunc(id)
}

// DeleteSessionByIDCalls gets all the calls that were made to DeleteSessionByID.
// Check the length with:
//     len(mockedauthRepository.DeleteSessionByIDCalls())
func (mock *authRepositoryMock) DeleteSessionByIDCalls() []struct {
	ID string
} {
	var calls []struct {
		ID string
	}
	lockauthRepositoryMockDeleteSessionByID.RLock()
	calls = mock.calls.DeleteSessionByID
	lockauthRepositoryMockDeleteSessionByID.RUnlock()
	return calls
}

// DeleteSessionByUserID calls DeleteSessionByUserIDFunc.
func (mock *authRepositoryMock) DeleteSessionByUserID(id uint) error {
	if mock.DeleteSessionByUserIDFunc == nil {
		panic("authRepositoryMock.DeleteSessionByUserIDFunc: method is nil but authRepository.DeleteSessionByUserID was just called")
	}
	callInfo := struct {
		ID uint
	}{
		ID: id,
	}
	lockauthRepositoryMockDeleteSessionByUserID.Lock()
	mock.calls.DeleteSessionByUserID = append(mock.calls.DeleteSessionByUserID, callInfo)
	lockauthRepositoryMockDeleteSessionByUserID.Unlock()
	return mock.DeleteSessionByUserIDFunc(id)
}

// DeleteSessionByUserIDCalls gets all the calls that were made to DeleteSessionByUserID.
// Check the length with:
//     len(mockedauthRepository.DeleteSessionByUserIDCalls())
func (mock *authRepositoryMock) DeleteSessionByUserIDCalls() []struct {
	ID uint
} {
	var calls []struct {
		ID uint
	}
	lockauthRepositoryMockDeleteSessionByUserID.RLock()
	calls = mock.calls.DeleteSessionByUserID
	lockauthRepositoryMockDeleteSessionByUserID.RUnlock()
	return calls
}

// FindSessionByAccessToken calls FindSessionByAccessTokenFunc.
func (mock *authRepositoryMock) FindSessionByAccessToken(token string) (*Session, error) {
	if mock.FindSessionByAccessTokenFunc == nil {
		panic("authRepositoryMock.FindSessionByAccessTokenFunc: method is nil but authRepository.FindSessionByAccessToken was just called")
	}
	callInfo := struct {
		Token string
	}{
		Token: token,
	}
	lockauthRepositoryMockFindSessionByAccessToken.Lock()
	mock.calls.FindSessionByAccessToken = append(mock.calls.FindSessionByAccessToken, callInfo)
	lockauthRepositoryMockFindSessionByAccessToken.Unlock()
	return mock.FindSessionByAccessTokenFunc(token)
}

// FindSessionByAccessTokenCalls gets all the calls that were made to FindSessionByAccessToken.
// Check the length with:
//     len(mockedauthRepository.FindSessionByAccessTokenCalls())
func (mock *authRepositoryMock) FindSessionByAccessTokenCalls() []struct {
	Token string
} {
	var calls []struct {
		Token string
	}
	lockauthRepositoryMockFindSessionByAccessToken.RLock()
	calls = mock.calls.FindSessionByAccessToken
	lockauthRepositoryMockFindSessionByAccessToken.RUnlock()
	return calls
}
